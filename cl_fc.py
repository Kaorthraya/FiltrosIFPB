# -*- coding: utf-8 -*-
"""cl_fc.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vOo2SJUOSCdwN6rL7sUBGzzABnTlzVeM
"""

import numpy as np
import math
from scipy import signal
from matplotlib import pyplot as plt
from matplotlib.ticker import (AutoMinorLocator)

class f_btrwrth:
    def __init__(self, tipo, **kwargs):
        self.a_p = kwargs['a_p']
        self.a_s = kwargs['a_s']
        self.w_s = kwargs.get('w_s', 0)
        self.w_p = kwargs.get('w_p', 0)
        self.w_s1 = kwargs.get('w_s1', 0)
        self.w_s2 = kwargs.get('w_s2', 0)
        self.w_p1 = kwargs.get('w_p1', 0)
        self.w_p2 = kwargs.get('w_p2', 0)
        self.tipo = tipo
        self.wc = 0.0
        self.Rl = 0
        self.top = ''
        self.roots = 0
        self.den_norm = 0

    def ordem(self):
        result = 0
        self.testa_par()
        if self.tipo == 'hp':
            result = int(np.ceil(np.log10((np.power(
            ((np.power(10.0, (-self.a_s / 10.0)) - 1.0) / (np.power(10.0, (-self.a_p / 10.0)) - 1.0)),
            0.5))) / np.log10((self.w_p / self.w_s))))
        if self.tipo == 'lp':
            result = int(np.ceil(np.log10((np.power(
            ((np.power(10.0, (-self.a_s / 10.0)) - 1.0) / (np.power(10.0, (-self.a_p / 10.0)) - 1.0)),
            0.5))) / np.log10((self.w_s / self.w_p))))
        return result

    def fq_corte(self, **kwargs):
        result = None
        if ('ordem' in kwargs):
            ordem = kwargs['ordem']
        else:
            ordem = self.ordem()
        if(self.tipo == 'hp'):
            result = self.w_p*(np.power((np.power(10.0, ((-1.0) * self.a_p / 10.0)) - 1.0), (1.0 / (2.0*ordem))))
        elif(self.tipo == 'lp'):
            result = self.w_p / (np.power((np.power(10.0, ((-1.0) * self.a_p / 10.0)) - 1.0), (1.0 / (2.0 * ordem))))
        self.wc = result
        return result

    def raizes_normal(self, **kwargs):
        if ('ordem' in kwargs):
            ordem = kwargs['ordem']
        else:
            ordem = self.ordem()
        S_k = np.zeros(ordem, dtype=complex)
        for i in range(1, ordem + 1):
            S_k[i - 1] = -np.sin(np.pi * (2 * i - 1) / (2 * ordem)) + (
                        1j * np.cos(np.pi * (2 * i - 1) / (2 * ordem)))  # cálculo das raízes
        self.roots = S_k
        return self.roots

    def transfunc(self, polos, wc):
        fcn = 0
        if self.tipo == 'lp':
            self.den_norm = np.real(np.poly(polos))
            denm = np.zeros(len(self.den_norm))
            for i in range(0, len(polos) + 1):
                denm[i] = self.den_norm[i] * np.power(wc, i)
            num = denm[-1]
            fcn = signal.TransferFunction(num, denm)
        if self.tipo == 'hp':
            self.den_norm = np.real(np.poly(polos))
            denm = np.zeros(len(polos) + 1)
            for i in range(0, len(polos) + 1):
                denm[i] = self.den_norm[len(polos) - i] * np.power(wc, i)
            num = np.zeros(len(polos) + 1)
            num[0] = denm[0]
            fcn = signal.TransferFunction(num, denm)
        return fcn

    def plot_bode(self, fcn, **kwargs):
        if 'max_f' in kwargs:
            max_f = kwargs['max_f']
        else:
            max_f = self.w_s
        if 'min_f' in kwargs:
            min_f = float(kwargs['min_f'])
        else:
            min_f = 0
        if 'points' in kwargs:
            points = kwargs['points']
        else:
            points = 100

        w, amp, fase = fcn.bode(w=np.arange(min_f, max_f, (max_f - min_f)/points))
        fig, ax = plt.subplots()  # cria os plots
        ax.semilogx(w, amp)  # gráfico do tipo semilog
        ax.set(xlabel="Frequência (rad/s)", ylabel="Amplitude em dB",
               title="Resposta em amplitude (BTRWRTH n = %d)" %self.ordem()) # configuração de plot label
        ax.margins(x=0)
        ax.margins(y=0.05)  # margem y
        ax.grid(True, which="both")  # grid
        bp = ax.scatter(self.w_p, self.a_p)  # ponto de projeto de passagem
        br = ax.scatter(self.w_s, self.a_s)  # ponto de projeto de rejeição
        ax.legend((bp, br), ("P. Projeto (passagem)", "P. Projeto (rejeição)"), loc='lower left', fontsize=8)
        ax.yaxis.set_minor_locator(AutoMinorLocator())
        return fig

    def elements(self, wc, topologia, R,**kwargs):                  #Calcula os elementos escalonados em frequência
        if ('ordem' in kwargs):                                     #Calcula a ordem, caso seja chamado antes
            ordem = kwargs['ordem']
        else:
            ordem = self.ordem()
        self.top = topologia
        self.Rl = R
        nomes = np.empty(ordem, dtype="<U2")
        val = np.zeros(ordem)
        elem_table = 2*abs(np.real(self.roots))                     #Utiliza a formula Cauer para calcular os elementos da tabela Butterworth
        esq_dir = elem_table[::-1]                                  #Coloca os elementos na ordem inversa da tabela, para coincidir o primeiro elemento a depender da self.topologia
        if(self.tipo == 'lp'):                                      #Cálculo para FPB
            elem_fpb = esq_dir/wc                                   #Escalonamento em frequência (independe se é L ou C)
            if(topologia == 'CLC'):                                 #Inicia com capacitor
                val, nomes = self.__Zscale(ordem, elem_fpb, R, topologia)
            if(topologia == 'LCL'):
                val, nomes = self.__Zscale(ordem, elem_fpb, R, topologia)
        if(self.tipo == 'hp'):
            elem_fpa = (np.float_power(esq_dir, -1))*(1/wc)                                   #Escalonamento em frequência (independe se é L ou C)
            if(topologia == 'CLC'):
                val, nomes = self.__Zscale(ordem, elem_fpa, R, topologia)
            if(topologia == 'LCL'):
                val, nomes = self.__Zscale(ordem, elem_fpa, R, topologia)
        return val, nomes                                           #Retorna os elementos

    def __Zscale(self, N, elementos, R, topologia):
        name = np.empty(N, dtype="<U2")
        elem_final = np.zeros(N)
        if(topologia == 'CLC'):                                     #Primeiro elemento é capacitor
            for i in range(1, N+1):                                 #Varre todos os elementos
                if(i%2 != 0):                                       #Se começa com capacitor, todos os elementos ímpares são capacitores
                    elem_final[i-1] = elementos[i-1]/R              #Capacitor
                    name[i-1] = "C" + str(N-i+1)                    #Nome do elemento + numero (ordem do número segue o Paarman L.)
                else:                                               #Se par, é indutor
                    elem_final[i-1] = elementos[i-1]*R              #Indutor
                    name[i-1] = "L" + str(N-i+1)                    #Nome do elemento + numero (ordem do número segue o Paarman L.)
        if(topologia == 'LCL'):                                     #Primeiro elemento é indutor
            for i in range(1, N+1):                                 #Varre todos os elementos
                if(i%2 != 0):                                       #Se começa com indutor, todos os elementos ímpares são indutores
                    elem_final[i-1] = elementos[i-1]*R              #Indutor
                    name[i-1] = "L" + str(N-i+1)                    #Nome do elemento + numero (ordem do número segue o Paarman L.)

                else:                                               #Se par, então é capacitor
                    elem_final[i-1] = elementos[i-1]/R              #Capacitor
                    name[i-1] = "C" + str(N-i+1)                    #Nome do elemento + numero (ordem do número segue o Paarman L.)
        return elem_final, name

    def exporttxt(self, arq_nome):
        with open(arq_nome, 'w') as f:
            f.write('Detalhamento do filtro\n')
            f.write('Pontos de projeto escolhidos:\n')
            f.write('   Filtro: Butterworth\n')
            f.write('   Resposta: ' + str(self.tipo.upper()) + '\n')
            f.write('   Ordem: ' + str(self.ordem()) + '\n')
            f.write('   Frequência de corte: ' + str(self.wc) + '\n')
            f.write('\nComponentes do circuito:\n')
            f.write('   Topologia: ' + str(self.top) + '\n')
            valor, nome = self.elements(self.wc, self.top, self.Rl)
            f.write("   Elementos escalonados: \n")
            for i in range(0, self.ordem()):
                f.write('     %s = %s\n' %(nome[i], eng_string(valor[i], si=True)))
            f.write("\n")
            
           

    def testa_par(self):
        if (self.tipo == 'hp') and ((self.w_s >= self.w_p) or (self.a_s >= self.a_p)):
            raise ValueError("Inversão dos parâmetros para um HP")
        if (self.tipo == 'lp') and ((self.w_s <= self.w_p) or (self.a_s >= self.a_p)):
            raise ValueError("Inversão dos parâmetros para um LP")

def eng_string( x, format='%s', si=False):
    sign = ''
    if x < 0:
        x = -x
        sign = '-'
    exp = int( math.floor( math.log10( x)))
    exp3 = exp - ( exp % 3)
    x3 = x / ( 10 ** exp3)

    if si and exp3 >= -24 and exp3 <= 24 and exp3 != 0:
        exp3_text = 'yzafpnum kMGTPEZY'[ int(( exp3 - (-24)) / 3)]
    elif exp3 == 0:
        exp3_text = ''
    else:
        exp3_text = 'e%s' % exp3

    return ( '%s'+format+'%s') % ( sign, "{:.2f}".format(x3), exp3_text)