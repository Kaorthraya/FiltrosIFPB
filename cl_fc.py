# -*- coding: utf-8 -*-
"""cl_fc.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vOo2SJUOSCdwN6rL7sUBGzzABnTlzVeM
"""

import numpy as np
import math
from scipy import signal
from matplotlib.ticker import (AutoMinorLocator)

class f_btrwrth:
    def __init__(self, tipo, **kwargs):
        self.a_p = kwargs['a_p']
        self.a_s = kwargs['a_s']
        self.w_s = kwargs.get('w_s', 0)
        self.w_p = kwargs.get('w_p', 0)
        self.w_s1 = kwargs.get('w_s1', 0)
        self.w_s2 = kwargs.get('w_s2', 0)
        self.w_p1 = kwargs.get('w_p1', 0)
        self.w_p2 = kwargs.get('w_p2', 0)
        self.tipo = tipo
        self.den_norm = 0
        self.elem_scale = 0
        self.elementos = 0

    def ordem(self):
        result = 0
        self.testa_par()
        if self.tipo == 'hp':
            result = int(np.ceil(np.log10((np.power(
            ((np.power(10.0, (-self.a_s / 10.0)) - 1.0) / (np.power(10.0, (-self.a_p / 10.0)) - 1.0)),
            0.5))) / np.log10((self.w_p / self.w_s))))
        if self.tipo == 'lp':
            result = int(np.ceil(np.log10((np.power(
            ((np.power(10.0, (-self.a_s / 10.0)) - 1.0) / (np.power(10.0, (-self.a_p / 10.0)) - 1.0)),
            0.5))) / np.log10((self.w_s / self.w_p))))
        return result

    def fq_corte(self, **kwargs):
        result = None
        if ('ordem' in kwargs):
            ordem = kwargs['ordem']
        else:
            ordem = self.ordem()
        if(self.tipo == 'hp'):
            result = self.w_p*(np.power((np.power(10.0, ((-1.0) * self.a_p / 10.0)) - 1.0), (1.0 / (2.0*ordem))))
        elif(self.tipo == 'lp'):
            result = self.w_p / (np.power((np.power(10.0, ((-1.0) * self.a_p / 10.0)) - 1.0), (1.0 / (2.0 * ordem))))
        return result

    def raizes_normal(self, **kwargs):
        if ('ordem' in kwargs):
            ordem = kwargs['ordem']
        else:
            ordem = self.ordem()
        S_k = np.zeros(ordem, dtype=complex)
        for i in range(1, ordem + 1):
            S_k[i - 1] = -np.sin(np.pi * (2 * i - 1) / (2 * ordem)) + (
                        1j * np.cos(np.pi * (2 * i - 1) / (2 * ordem)))  # cálculo das raízes
        return S_k

    def transfunc(self, polos, wc):
        if self.tipo == 'lp':
            self.den_norm = np.real(np.poly(polos))
            denm = np.zeros(len(self.den_norm))
            for i in range(0, len(polos) + 1):
                denm[i] = self.den_norm[i] * np.power(wc, i)
            num = denm[-1]
            fcn = signal.TransferFunction(num, denm)
        if self.tipo == 'hp':
            self.den_norm = np.real(np.poly(polos))
            denm = np.zeros(len(polos) + 1)
            for i in range(0, len(polos) + 1):
                denm[i] = self.den_norm[len(polos) - i] * np.power(wc, i)
            num = np.zeros(len(polos) + 1)
            num[0] = denm[0]
            fcn = signal.TransferFunction(num, denm)
        return fcn

    def plot_bode(self, fcn, **kwargs):
        if 'max_f' in kwargs:
            max_f = kwargs['max_f']
        else:
            max_f = self.w_s
        if 'min_f' in kwargs:
            min_f = float(kwargs['min_f'])
        else:
            min_f = 0
        if 'points' in kwargs:
            points = kwargs['points']
        else:
            points = 100

        w, amp, fase = fcn.bode(w=np.arange(min_f, max_f, (max_f - min_f)/points))
        fig, ax = plt.subplots()  # cria os plots
        ax.semilogx(w, amp)  # gráfico do tipo semilog
        ax.set(xlabel="Frequência (rad/s)", ylabel="Amplitude em dB",
               title="Resposta em amplitude (BTRWRTH n = %d)" %self.ordem()) # configuração de plot label
        ax.margins(x=0)
        ax.margins(y=0.05)  # margem y
        ax.grid(True, which="both")  # grid
        bp = ax.scatter(self.w_p, self.a_p)  # ponto de projeto de passagem
        br = ax.scatter(self.w_s, self.a_s)  # ponto de projeto de rejeição
        ax.legend((bp, br), ("P. Projeto (passagem)", "P. Projeto (rejeição)"), loc='lower left', fontsize=8)
        ax.yaxis.set_minor_locator(AutoMinorLocator())
        return fig

    def elements(self, r, wc, topologia ,**kwargs):
        if ('ordem' in kwargs):
            ordem = kwargs['ordem']
        else:
            ordem = self.ordem()
        
        elem = np.zeros(ordem)                                          #Inicia a variavel que armazena o elementos não escalonados
        elem_inv = np.zeros(ordem)                                      #Inicia o vetor que recebe o elementos em ordem reversa
        self.elementos = np.zeros(ordem)                                #Guarda os elementos escalonados
        
        elem_name = np.empty((1,ordem), dtype="<U2")                    #Cria o vetor que vai guardar a ordem dos elementos (L ou C)
        elem = 2*abs(np.real(self.raizes_normal()))                     #Calcula os elementos n escalonados a partir das raizes
        elem_inv = elem[::-1]                                           #Faz a inversão dos elementos (Xn, Xn-1, ..., X1)
        
        if(self.tipo == 'lp'):                                          #Para um passa-baixa
            self.elem_scale = elem_inv/self.fq_corte()
            if(topologia == 'CLC'):                                     #(Para topologia CLC)
                for i in range(1, ordem+1):
                    if(i%2 != 0):
                        self.elementos[i-1] = self.elem_scale[i-1]/r    #CAPACITOR
                        elem_name[0][i-1] = 'C' + str(ordem-i+1)
                    else:
                        self.elementos[i-1] = self.elem_scale[i-1]*r    #INDUTOR
                        elem_name[0][i-1] = 'L' + str(ordem-i+1)
            elif(topologia == 'LCL'):                                   #(Para topologia LCL)
                for i in range(1, ordem+1):
                    if(i%2 != 0):
                        self.elementos[i-1] = self.elem_scale[i-1]*r    #INDUTOR
                        elem_name[0][i-1] = 'L' + str(ordem-i+1)
                    else:
                        self.elementos[i-1] = self.elem_scale[i-1]/r    #CAPACITOR
                        elem_name[0][i-1] = 'C' + str(ordem-i+1)
        #Implementação para o passa-alta
        return self.elementos, elem_name                                #Retorna os elementos


    def testa_par(self):
        if (self.tipo == 'hp') and ((self.w_s >= self.w_p) or (self.a_s >= self.a_p)):
            raise ValueError("Inversão dos parâmetros para um HP")
        if (self.tipo == 'lp') and ((self.w_s <= self.w_p) or (self.a_s >= self.a_p)):
            raise ValueError("Inversão dos parâmetros para um LP")

def eng_string( x, format='%s', si=False):
    sign = ''
    if x < 0:
        x = -x
        sign = '-'
    exp = int( math.floor( math.log10( x)))
    exp3 = exp - ( exp % 3)
    x3 = x / ( 10 ** exp3)

    if si and exp3 >= -24 and exp3 <= 24 and exp3 != 0:
        exp3_text = 'yzafpnum kMGTPEZY'[ int(( exp3 - (-24)) / 3)]
    elif exp3 == 0:
        exp3_text = ''
    else:
        exp3_text = 'e%s' % exp3

    return ( '%s'+format+'%s') % ( sign, "{:.2f}".format(x3), exp3_text)